"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _jsYaml = _interopRequireWildcard(require("js-yaml"));

var _directives = _interopRequireDefault(require("./directives"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** @module */
const createPatterns = keys => {
  const set = new Set();

  for (const k of keys) {
    const normalized = '_?' + k.replace(/[.*+?^=!:${}()|[\]\\/]/g, '\\$&');
    set.add(normalized);
    set.add(`"${normalized}"`);
    set.add(`'${normalized}'`);
  }

  return [...set.values()];
};

const yamlSpecialChars = `["'{|>~&*`;

function parse(text) {
  try {
    const obj = _jsYaml.default.load(text, {
      schema: _jsYaml.FAILSAFE_SCHEMA
    });

    if (obj === null || typeof obj !== 'object') return false;
    return obj;
  } catch (e) {
    return false;
  }
}

function convertLoose(text, looseDirectives) {
  const keyPattern = `(?:${createPatterns(looseDirectives).join('|')})`;
  const looseMatcher = new RegExp(`^(${keyPattern}\\s*:)(.+)$`);
  let normalized = '';

  for (const line of text.split(/\r?\n/)) normalized += `${line.replace(looseMatcher, (original, prop, value) => {
    const trimmed = value.trim();
    if (trimmed.length === 0 || yamlSpecialChars.includes(trimmed[0])) return original;
    const spaceLength = value.length - value.trimLeft().length;
    const spaces = value.substring(0, spaceLength);
    return `${prop}${spaces}"${trimmed.split('"').join('\\"')}"`;
  })}\n`;

  return normalized.trim();
}
/**
 * Parse text as YAML by using js-yaml's FAILSAFE_SCHEMA.
 *
 * @alias module:markdown/directives/yaml
 * @param {String} text Target text.
 * @param {boolean|string[]} [looseDirectives=false] By setting `true`, it try
 *     to parse as loose YAML only in defined Marpit built-in directives. You
 *     may also extend target keys for loose parsing by passing an array of
 *     strings.
 * @returns {Object|false} Return parse result, or `false` when failed to parse.
 */


var _default = (text, looseDirectives = false) => parse(looseDirectives ? convertLoose(text, [..._directives.default, ...(Array.isArray(looseDirectives) ? looseDirectives : [])]) : text);

exports.default = _default;